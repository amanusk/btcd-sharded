// Copyright (c) 2016 The Decred developers
// Copyright (c) 2016-2017 The btcsuite developers Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

package blockchain_test

import (
	_ "bytes"
	"flag"
	"fmt"
	reallog "log"
	"net"
	"os"
	_ "path/filepath"
	"strings"
	"testing"

	"database/sql"
	_ "github.com/lib/pq"

	"github.com/btcsuite/btcd/blockchain"
	"github.com/btcsuite/btcd/blockchain/fullblocktests"
	"github.com/btcsuite/btcd/chaincfg"
	_ "github.com/btcsuite/btcd/chaincfg/chainhash"
	"github.com/btcsuite/btcd/database"
	_ "github.com/btcsuite/btcd/database/ffldb"
	"github.com/btcsuite/btcd/txscript"
	"github.com/btcsuite/btcd/wire"
	"github.com/btcsuite/btcutil"
)

const (
	// testDbType is the database backend type to use for the tests.
	testDbType = "ffldb"

	// testDbRoot is the root directory used to create all test databases.
	testDbRoot = "testdbs"

	// blockDataNet is the expected network in the test block data.
	blockDataNet = wire.MainNet
)

// filesExists returns whether or not the named file or directory exists.
func fileExists(name string) bool {
	if _, err := os.Stat(name); err != nil {
		if os.IsNotExist(err) {
			return false
		}
	}
	return true
}

// isSupportedDbType returns whether or not the passed database type is
// currently supported.
func isSupportedDbType(dbType string) bool {
	supportedDrivers := database.SupportedDrivers()
	for _, driver := range supportedDrivers {
		if dbType == driver {
			return true
		}
	}

	return false
}

// Function to open the sqlDB to use with our blockchain
// DB needs to be created and running
// Start with cockroach start --insecure --host=localhost
func openDB() *sql.DB {
	// Open the sql DB and join it
	db, err := sql.Open("postgres", "postgresql://amanusk@localhost:26257/blockchain?sslmode=disable")
	if err != nil {
		panic(err)
	}

	return db
}

// chainSetup is used to create a new db and chain instance with the genesis
// block already inserted.  In addition to the new chain instance, it returns
// a teardown function the caller should invoke when done testing to clean up.
func chainSetup(dbName string, params *chaincfg.Params) (*blockchain.BlockChain, func(), error) {

	// Handle memory database specially since it doesn't need the disk
	// specific handling.
	var teardown func()
	sqlDB := openDB()

	// Setup a teardown function for cleaning up.  This function is
	// returned to the caller to be invoked when it is done testing.
	teardown = func() {
		sqlDB.Close()
	}

	// Copy the chain params to ensure any modifications the tests do to
	// the chain parameters do not affect the global instance.
	paramsCopy := *params

	// Create the main chain instance.
	chain, err := blockchain.SqlNew(&blockchain.Config{
		SqlDB:       sqlDB,
		ChainParams: &paramsCopy,
		Checkpoints: nil,
		TimeSource:  blockchain.NewMedianTime(),
		SigCache:    txscript.NewSigCache(1000),
	})
	if err != nil {
		teardown()
		err := fmt.Errorf("failed to create chain instance: %v", err)
		return nil, nil, err
	}
	return chain, teardown, nil
}

var flagMode *string

func init() {
	flagMode = flag.String("mode", "server", "start in client or server mode")
	flag.Parse()
}

// TestFullBlocks ensures all tests generated by the fullblocktests package
// have the expected result when processed via ProcessBlock.
func TestFullBlocksSQL(t *testing.T) {

	if strings.ToLower(*flagMode) == "server" {
		fmt.Print("Server mode\n")

		// Setting up my logging system
		f, err := os.OpenFile("testlog.log", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
		defer f.Close()
		reallog.SetOutput(f)
		reallog.SetFlags(reallog.Lshortfile)
		reallog.Println("This is a test log entry")

		tests, err := fullblocktests.SimpleGenerate(false)
		if err != nil {
			t.Fatalf("failed to generate tests: %v", err)
		}

		// Create a new database and chain instance to run tests against.
		chain, teardownFunc, err := chainSetup("fullblocktest",
			&chaincfg.RegressionNetParams)
		if err != nil {
			t.Errorf("Failed to setup chain instance: %v", err)
			return
		}
		defer teardownFunc()

		// Start listener on port 12345 for coordinator
		fmt.Println("Starting server...")
		listener, error := net.Listen("tcp", ":12345")
		if error != nil {
			fmt.Println(error)
		}

		manager := blockchain.NewCoordinator(listener, chain)
		go manager.Start()

		// Wait for all the clients to get connected
		for manager.GetNumClientes() < 0 {
			connection, _ := manager.Listener.Accept()
			client := blockchain.NewClient(connection)
			manager.Register(client)
			go manager.Receive(client)
			go manager.Send(client)
			// Will continue loop once a client has connected
			<-manager.Connected
		}

		// testAcceptedBlock attempts to process the block in the provided test
		// instance and ensures that it was accepted according to the flags
		// specified in the test.
		testAcceptedBlock := func(item fullblocktests.AcceptedBlock) {
			blockHeight := item.Height
			block := btcutil.NewBlock(item.Block)
			block.SetHeight(blockHeight)
			t.Logf("Testing block %s (hash %s, height %d)",
				item.Name, block.Hash(), blockHeight)

			manager.Chain.SqlProcessBlock(block, blockchain.BFNone)
			if err != nil {
				t.Fatalf("block %q (hash %s, height %d) should "+
					"have been accepted: %v", item.Name,
					block.Hash(), blockHeight, err)
			}

			// Ensure the main chain and orphan flags match the values
			// specified in the test.
			//if isMainChain != item.IsMainChain {
			//	t.Fatalf("block %q (hash %s, height %d) unexpected main "+
			//		"chain flag -- got %v, want %v", item.Name,
			//		block.Hash(), blockHeight, isMainChain,
			//		item.IsMainChain)
			//}
			//if isOrphan != item.IsOrphan {
			//	t.Fatalf("block %q (hash %s, height %d) unexpected "+
			//		"orphan flag -- got %v, want %v", item.Name,
			//		block.Hash(), blockHeight, isOrphan,
			//		item.IsOrphan)
			//}
		}
		t.Log("Started testing blocks")
		for testNum, test := range tests {
			for itemNum, item := range test {
				switch item := item.(type) {
				case fullblocktests.AcceptedBlock:
					testAcceptedBlock(item)
				//case fullblocktests.RejectedBlock:
				//	testRejectedBlock(item)
				//case fullblocktests.RejectedNonCanonicalBlock:
				//	testRejectedNonCanonicalBlock(item)
				//case fullblocktests.OrphanOrRejectedBlock:
				//	testOrphanOrRejectedBlock(item)
				//case fullblocktests.ExpectedTip:
				//	testExpectedTip(item)
				default:
					t.Fatalf("test #%d, item #%d is not one of "+
						"the supported test instance types -- "+
						"got type: %T", testNum, itemNum, item)
				}
			}
		}
	} else {
		fmt.Print("Server mode\n")
		blockchain.StartClientMode()
	}
}
